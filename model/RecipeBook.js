const meas = require('./Measurement.js');
const rec = require('./Recipe.js');
const fd = require('./Food.js');
const nut = require('./Nutrition.js');




/*
 * RecipeBook stores all our recipes and foods, providing functions to add/delete/edit
 * as well as search foods/recipes. saveString should be a JSON string previously
 * generated by the saveString function or null for an empty RecipeBook
 */
function RecipeBook(saveString) {
  let nextRid, nextFid;
  let recipeList = {};
  let foodList = {};

  if(saveString == null) {
    nextRid = 0;
    recipeList = {};
    nextFid = 0;
    foodList = {};
  } else {
    try {
      let saveData = JSON.parse(saveString);
      let savedRecipes = saveData.recipeList;
      let savedFoods = saveData.foodList;
      nextRid = saveData.nextRid;

      if(nextRid == null) {
        nextRid = 0;
      }

      Object.keys(savedRecipes).forEach((rid) => {
        recipeList[rid] = new rec.Recipe(savedRecipes[rid]);
      });

      nextFid = saveData.nextFid;
      if(nextFid == null) {
        nextFid = 0;
      }

      Object.keys(savedFoods).forEach((fid) => {
        foodList[fid] = new fd.Food(savedFoods[fid]);
      });

    } catch(error) {
      console.log("Malformed RecipeBook file, creating an empty one");
      console.log(error);
      RecipeBook();
    }
  }

  function getInvalidChildren(parentRid) {
    let invalidChildren = new Set();
    invalidChildren.add(parseInt(parentRid));
    Object.keys(recipeList).forEach(function(rid) {
      if(!invalidChildren.has(parseInt(rid)) && hasInvalidChild(rid, invalidChildren)) {
        console.log("adding rid " + rid + " to invalid children");
        invalidChildren.add(parseInt(rid));
      }
    });

    function hasInvalidChild(descRid, invalidChildren) {
      let recipe = recipeList[descRid];
      Object.keys(recipe.subRecipes).forEach((subRid) => {
        if(invalidChildren.has(parseInt(subRid))) {
          return true;
        } else {
          return hasInvalidChild(subRid, invalidChildren);
        }
      });
      return false;
    }

    return invalidChildren;
  }


  this.saveString = function() {
    let newSaveData = {};
    newSaveData.nextRid = nextRid;
    newSaveData.recipeList = recipeList;
    newSaveData.nextFid = nextFid;
    newSaveData.foodList = foodList;
    return JSON.stringify(newSaveData);
  },

  this.newRecipe = function() {
    let newRid = nextRid;
    nextRid++;
    recipeList[newRid] = new rec.Recipe();
    return newRid;
  },

  this.isRecipe = function(rid) {
    return recipeList.hasOwnProperty(rid);
  },

  this.getRecipe = function(rid) {
    if(this.isRecipe(rid)) {
      return recipeList[rid];
    } else {
      return null;
    }

  },

  this.saveRecipe = function(rid, recipe) {
    if(recipe != null) {
      recipeList[rid] = recipe;
    }
  },

  this.deleteRecipe = function(rid) {
    delete recipeList[rid];
  },

  this.allRecipes = function() {
    let results = {};
    Object.keys(recipeList).forEach((rid) => {
      results[rid] = recipeList[rid];
    });
    return results;
  },

  this.searchRecipes = function(searchString, parent) {
    let results = {};
    let noReturn;
    if(parent == null) {
      noReturn = new Set();
    } else {
      noReturn = getInvalidChildren(parent);
    }

    Object.keys(recipeList).forEach(function(validChildRid) {
      if(!noReturn.has(parseInt(validChildRid))) {
        let name = recipeList[validChildRid].name;
        if(name.toUpperCase().startsWith(searchString.toUpperCase())) {
          results[validChildRid] = name;
        }
      }
    });

    return results;


  },

  this.newFood = function() {
    let newFid = nextFid;
    nextFid++;
    foodList[newFid] = new fd.Food();
    return newFid;
  },

  this.isFood = function(fid) {
    return foodList.hasOwnProperty(fid);
  },

  this.getFood = function(fid) {
    return foodList[fid];
  },



  this.saveFood = function(fid, food) {
    if(food != null) {
      foodList[fid] = food;
    }
  },

  this.deleteFood = function(fid) {
    delete foodList[fid];
  }

  this.searchFoods = function(searchString) {
    let results = {};
    Object.keys(foodList).forEach((fid) => {
      if(foodList[fid].name.toUpperCase().startsWith(searchString.toUpperCase())) {
        results[fid] = foodList[fid].name;
      }
    });
    return results;
  }

  this.allFoods = function() {
    return this.searchFoods("");
  }

  this.ingredientString = function(rid) {
    let recipe = recipeList[rid];
    let ingredients = "";

    let sortedSubRecipes = Object.keys(recipe.subRecipes);
    sortedSubRecipes.sort(function(rid1, rid2) {
      return recipe.subRecipes[rid1].amountInUnit(0) -
                recipe.subRecipes[rid2].amountInUnit(0);
    });

    let sortedSubFoods = Object.keys(recipe.subFoods);
    sortedSubFoods.sort(function(fid1, fid2) {
      return recipe.subFoods[fid1].amountInUnit(0) -
                recipe.subFoods[fid2].amountInUnit(0);
    });

    while(sortedSubRecipes.length > 0 || sortedSubFoods.length > 0) {
      let recipeAmount = -1;
      let foodAmount = -1;
      if(sortedSubRecipes.length > 0) {
        recipeAmount = recipe.subRecipes[sortedSubRecipes[sortedSubRecipes.length - 1]].amountInUnit(0);
      }

      if(sortedSubFoods.length > 0) {
        foodAmount = recipe.subFoods[sortedSubFoods[sortedSubFoods.length - 1]].amountInUnit(0);
      }

      if(recipeAmount > foodAmount) {
        let rid = sortedSubRecipes.pop();
        let name = recipeList[rid].name;
        ingredients += name + "(" + this.ingredientString(rid) + "), ";
      } else {
        let fid = sortedSubFoods.pop();
        let name = foodList[fid].name;
        ingredients += name + ", ";
      }

    }
    return ingredients.slice(0, -2);

  }

  this.calcCost = function(rid, quantity) {
    console.log("calculating cost for quantity: " + quantity.amount);
    if(recipeList.hasOwnProperty(rid)) {
      let recipe = recipeList[rid];
      console.log("amount in unit is: " + quantity.amountInUnit(0));
      let foodTotals = totalFoods(rid, quantity.amountInUnit(0));
      console.log("foodTotals is: " + JSON.stringify(foodTotals));
      let totalCost = 0;
      Object.keys(foodTotals).forEach((fid) => {
        let cost = foodList[fid].cost.costPerGram() * foodTotals[fid];
        totalCost += cost;
      });

      return totalCost * 100 / 100.0;
    }

    return null;
  }

  this.calcNutrition = function(rid) {
    if(recipeList.hasOwnProperty(rid)) {
      let recipe = recipeList[rid];
      let foodTotals = totalFoods(rid, recipe.servingSize.amountInUnit(0));

      let nutrients = totalNutrients(foodTotals);
      return nutrients;
    } else {
      return null;
    }

    function totalNutrients(foodTotals) {
      let nutrients = {};
      Object.keys(nut.NUTRIENT_LIST).forEach(function(nutrient) {
        nutrients[nutrient] = 0;
      });

      Object.keys(foodTotals).forEach(function(fid) {
        let food = foodList[fid];
        let scalingFactor = foodTotals[fid] * 1.0 / food.servingSize.amountInUnit(0);
        Object.keys(food.nutrients).forEach(function(nutrient) {
          nutrients[nutrient] += food.nutrients[nutrient] * scalingFactor;
        });
      });

      return nutrients;
    }
  }

  function totalFoods(rid, amount) {
    let recipe = recipeList[rid];
    let foodTotals = {};

    let totalGrams = 0;

    //
    Object.keys(recipe.subFoods).forEach(function(subFid) {
      console.log("iterating subFood: " + subFid);
      let amountInGrams = recipe.subFoods[subFid].amountInUnit(0);
      if(foodTotals.hasOwnProperty(subFid)) {
        foodTotals[subFid] += amountInGrams;
      } else {
        foodTotals[subFid] = amountInGrams;
      }

      totalGrams += amountInGrams;
    });
    console.log("totalGrams is: " + totalGrams + " after iterating subFoods");

    Object.keys(recipe.subRecipes).forEach(function(subRid) {
      console.log("iterating subRecipe: " + subRid);
      let amountInGrams = recipe.subRecipes[subRid].amountInUnit(0);
      let subRecipeFoods = totalFoods(subRid, amountInGrams);
      Object.keys(subRecipeFoods).forEach(function(subRecipeFid) {
        if(foodTotals.hasOwnProperty(subRecipeFid)) {
          foodTotals[subRecipeFid] += subRecipeFoods[subRecipeFid];
        } else {
          foodTotals[subRecipeFid] = subRecipeFoods[subRecipeFid];
        }
      });

      totalGrams += amountInGrams;
    });
    console.log("totalGrams is: " + totalGrams + " after iterating subRecipes");
    console.log("un-scaled foods is: " + JSON.stringify(foodTotals));

    //Now we need to scale down to the proper amount:
    //make sure no rounding:
    let conversionFactor = amount * 1.0 / totalGrams;

    console.log("amount is: " + amount);
    console.log("totalGrams is " + totalGrams);
    console.log("conversionFactor is " + conversionFactor);

    let scaledFoods = {};
    Object.keys(foodTotals).forEach(function(fid) {
      scaledFoods[fid] = foodTotals[fid] * conversionFactor;
    });

    return scaledFoods;
  }

}

module.exports = {
  RecipeBook
}
